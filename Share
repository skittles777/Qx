格式化输入和输出：
转换说明符(放在%后面)：c, d, u, f, e,E, o, x,X, s
scanf函数
格式：scanf()
scanf()函数的参数输入类型不匹配问题
对于scanf("%d%c",&a,&c)，scanf语句执行时，首先试图从缓冲区中读入一个%d类型的数据，如果和第一个参数匹配，则继续从缓冲区中读取数据和第二个参数进行匹配，依次进行下去，直到匹配完所有的参数；
如果其中有一个参数不匹配，那就从这个地方跳出，忽略这个 scanf后面所有的参数，而去执行下一条语句。
例：scanf（“%3d%2x”,&a,&b）,输入26a23，变量b输出_____.
printf函数
格式：printf(格式字符串，待打印项1，待打印项2，...)；
例：printf("%d,d%",i++,i++)，从右往左执行；

指针：
指针是个量，对应一块内存区域；
指针存储的是某个内存单元的地址；
访问方式：
1、直接访问：按变量地址存取变量值，取地址符&；
2、间接访问：通过存放变量地址的变量去访问变量，间接运算符*；
在函数中改变一个外部变量，需要变量的地址；
若是数据，需要指向数据的指针存储数据的地址；
若是指针，需要指向指针的指针存用户指针的地址；

数组与指针
p[i]等价于*(p+i)，&p[i]等价于p+i;
a[i][j]等价于*(*(a+i)+j)，&a[i][j]等价于*(a+i)+j， a[i]等价于*(a+i)；
行数组指针定义方法：数据类型（*指针变量名）[二维数组列数]；
二维数组地址不可变化，数据可以变化，可以在不修改地址的情况下管理数据，指针数组指向的数据不可变化，但地址可以变化，在不修改数据的情况下查看数据；
三维数组与指针，A[i][j][k]的三种表达形式：*(A[i][j]+k)、*(*(A[i]+j)+k)、*(*(*(A+i)+j)+k)；

函数与指针
若在程序中定义了一个函数，在编译时，编译系统为函数代码分配一段存储空间，这段存储空间的起始地址，称为这个函数的指针，int(*p)(int, int)，代表定义p是指向函数的指针变量，可以指向类型为整形且有两个整形参数的函数；
定义返回值为指针值的函数的一般形式：类型名 *函数名（参数列表）；
例：
char * getmemory1()
{
    char * p = NULL;
    p = "hello world";
    return p;
 }
char * getmemory2()
{
    char  *p =  "hello world";
    return p;
}//字符串存放在常量区，并不会因为函数调用的结束而消失，返回指向常量区的地址
char * getmemory3()
{
   char  p[] =  "hello world";
   return p;
}//在函数内部定义的str数组是一个局部变量，将“hello world”字符串存放在里面，当函数调用结束时，局部变量的内容将被操作系统自动收回

malloc和free函数
动态内存分配，无法知道内存具体位置时，想要绑定真正的内存空间，则要用到动态分配内存，原型为extern void* malloc(unsigned int size)，空指针可以转换为任何类型的指针，size仅仅是申请字节的大小，并不管申请的内存块中存储的数据类型，故申请内存的长度需通过“长度 x sizeof（类型）”的方式给出，使用完之后要用free释放内存；
一个类型的指针包含三个信息：地址、步长、内容如何解析；
在栈区开辟一段内存，系统会自己回收，在堆区开辟一段内存，需要手动用free释放；

calloc和realloc函数
calloc原型：void* calloc（unsigned int num，unsigned int size），num：对象个数，size：对象占据的内存字节数，功能是为已经分配的内存重新分配空间并复制内容，会自动将内存初始化为0；
realloc原型：voidrealloc（void ptr，unsigned int size），ptr：已分配的内存地址，size：重新分配的字节数

内存分区
C/C++中，内存分为：堆、栈、自由存储区、全局/静态存储区、常量存储区；
堆：由new分配的内存块，一般对应一个delete，若没用释放，则程序结束后操作系统自动回收；
栈：编译器需要的时候分配，不需要时自动清楚的变量的存储区，通常是局部变量、函数参数等；
自由存储区：由malloc等分配的内存块，必须用free释放；
全局存储区：全局变量和静态变量的存储区域，未初始化的两者在相邻存的另一块区域，程序结束后自动释放；
常量存储区：存放常量，不可修改；

结构体
结构体引用方式：结构体数组名[下标].成员名；
结构体指针变量引用成员形式：(*结构体指针名).成员名、结构体指针名->成员名、结构体变量名.成员名；

结构体字节对齐机制
结构体变量大小是能够被其最宽基本类型成员的大小所整除；
结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，若有需要编译器会在成员之间加上填充字节；
结构体总大小为结构体最宽基本类型成员大小的整数倍，若有需要编译器会在最末一个成员之后加上填充字节；

共同体union
使几个不同类型的变量共占一段内存(相互覆盖)，长度=最长成员所占字节数，不能同时对所有成员初始化；

深拷贝与浅拷贝
深拷贝：根据指针指向的值，重新申请内存，再以此将指针指向内容复制过来，有相互独立的内存空间，一般复制构造函数和strcpy等函数都是深拷贝；
浅拷贝：把对象（结构）里的值完全复制给另一个对象（结构），对于地址也是照抄，类的默认复制构造函数是将类中非静态成员变量逐个复制，是浅拷贝；

fopen打开模式
只读模式"r"打开文件，该文件必须存在，否则打开失败，r+,rb,rb+,rt,rt+模式打开文件，文件不存在也会失败；
只写模式"w"打开，文件存在则长度清0，不存在则建立文件，w+,wb,wb+,wt,wt+模式打开文件，文件不存在则建立文件；
a以附加的方式打开只写文件，若文件不存在，则建立文件，存在则在文件尾部添加数据，a+以附加的方式打开可读写文件，不存在则建立文件，存在则写入数据到文件尾，at二进制数据的追加，不存在则创建，只能写、at+读写打开一个文本文件，允许读或在文本末追加数据，ab二进制数据的追加，不存在则创建，只能写；

排序算法：
1、冒泡排序
在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。
2、插入排序
将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。
3、选择排序
在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。
4、快速排序：
若一组记录的排序码为（46, 79, 56, 38, 40, 84），按照升序冒泡排序一趟扫描的结果是：________________；快速排序，以第一个记录为基准得到的一次划分结果是：________________。
